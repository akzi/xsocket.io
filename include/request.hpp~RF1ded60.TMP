#pragma once
namespace xsocket_io
{
	class request
	{
	public:
		request()
		{
			init();
		}
		~request()
		{

		}
		std::string url()
		{
			return url_;
		}
		std::string path()
		{
			return path_;
		}
		xhttper::query get_query()
		{
			return query_;
		}
		std::string get_entry(const char *name)
		{
			using cmp = xutil::functional::strncasecmper;
			return http_parser_.get_header<cmp>(name);
		}
		std::string get_entry(const std::string &name)
		{
			using cmp = xutil::functional::strncasecmper;
			return http_parser_.get_header<cmp>(name.c_str());
		}
		std::string method()
		{
			return http_parser_.get_method();
		}
		void do_send_file(const std::string &filepath)
		{
			using get_extension = xutil::functional::get_extension;
			using get_filename = xutil::functional::get_filename;
			using get_rfc1123 = xutil::functional::get_rfc1123;
			using last_modified = xutil::vfs::last_modified;
			auto range = get_range();
			int64_t begin = 0;
			int64_t end = 0;
			std::ios_base::openmode  mode;

			mode = std::ios::binary | std::ios::in;
			std::fstream file;
			file.open(filepath.c_str(), mode);
			if (!file.good())
				return;

			file.seekg(0, std::ios::end);
			auto size = file.tellg();
			end = size;

			bool has_range = false;
			if (range.first != UINT64_MAX)
			{
				begin = range.first;
				has_range = true;
			}
			if (range.second != UINT64_MAX)
			{
				has_range = true;
				if (range.first == UINT64_MAX)
				{
					end = size;
					begin = (int64_t)size - range.second;
				}
				else
				{
					end = range.second;
				}
			}

			http_builder_.append_entry("Date", get_rfc1123()());
			http_builder_.append_entry("Connection", "keep-alive");
			http_builder_.append_entry("Content-Type", http_builder_.get_content_type(get_extension()(filepath)));
			http_builder_.append_entry("Content-Length", std::to_string(end - begin).c_str());
			http_builder_.append_entry("Content-Disposition", "attachment; filename=" + get_filename()(filepath));

			auto ssbuf = std::ostringstream();
			auto lm = last_modified()(filepath) + size;
			ssbuf << std::hex << lm;
			http_builder_.append_entry("Etag", ssbuf.str());
			if (has_range)
			{
				std::string content_range("bytes ");
				content_range.append(std::to_string(begin));
				content_range.append("-");
				content_range.append(std::to_string(end));
				content_range.append("/");
				content_range.append(std::to_string(size));

				http_builder_.set_status(206);
				http_builder_.append_entry("Accept-Range", "bytes");
				http_builder_.append_entry("Content-Range", content_range);
			}

			std::string buffer;
			buffer.resize(102400);
			auto coro_func = [&, this] {
				std::function<void()> resume_handle;
				file.seekg(begin, std::ios::beg);
				conn_.regist_send_callback([&](std::size_t len) {
					if (len == 0)
					{
						file.close();
						resume_handle();
						return;
					}
					if (begin == end)
					{
						file.close();
						resume_handle();
						return;
					}
					auto to_reads = std::min<uint64_t>(buffer.size(), end - begin);
					file.read((char*)buffer.data(), to_reads);
					auto gcount = file.gcount();
					if (gcount > 0)
					{
						conn_.async_send(buffer.data(), (uint32_t)gcount);
						begin += gcount;
					}
				});
				conn_.async_send(std::move(http_builder_.build_resp()));
				xcoroutine::yield(resume_handle);
			};
			xcoroutine::create(coro_func);
		}
	private:
		std::pair<uint64_t, uint64_t> get_range()
		{
			static std::pair<uint64_t, uint64_t>  noexist = { UINT64_MAX, UINT64_MAX };
			using strncasecmper = xutil::functional::strncasecmper;
			std::string range = http_parser_.get_header<strncasecmper>("Range");
			if (range.empty())
				return noexist;
			auto pos = range.find("=");
			if (pos == range.npos)
				return noexist;
			++pos;
			auto end = pos;
			auto begin = std::stoull(range.c_str() + pos, &end, 10);
			if (end == pos)
				begin = UINT64_MAX;
			pos = range.find('-');
			if (pos == range.npos)
				return noexist;
			++pos;
			if (pos == range.size())
				return{ begin, UINT64_MAX };

			return{ begin, std::stoull(range.c_str() + pos, 0, 10) };
		}
		void regist_recv_callback()
		{
			conn_.regist_recv_callback([this](char *data, std::size_t len) {
				if (!len)
					return on_close();
				recv_callback(data, len);
				if (is_close_)
					return on_close();
			});
		}
		void flush()
		{
			if (is_sending_ || !polling_)
				return;

			if (send_buffers_.size())
			{
				conn_.async_send(std::move(send_buffers_.front()));
				send_buffers_.pop_front();
				is_sending_ = true;
				return;
			}
			if (packet_buffers_.empty())
				return;
			std::string buffer;
			for (auto &itr : packet_buffers_)
			{
				buffer += detail::packet_msg(itr);
			}
			send_data(buffer, 200);
			packet_buffers_.clear();
		}
		void regist_send_callback()
		{
			conn_.regist_send_callback([this](std::size_t len) {
				if (!len)
					return on_close();
				is_sending_ = false;
				flush();
			});
		}
		void init()
		{
			url_ = http_parser_.url();
			auto pos = url_.find('?');
			if (pos == url_.npos)
			{
				path_ = url_;
				return;
			}
			path_ = url_.substr(0, pos);
			pos++;
			auto args = url_.substr(pos, url_.size() - pos);
			query_ = std::move(xhttper::query(args));
		}
		xhttper::http_parser http_parser_;
		xhttper::http_builder http_builder_;
		xnet::connection conn_;
		std::string url_;
		std::string path_;
		xhttper::query query_;
	};
}